## 11.2 Express의 큰그림, 중요 포인트!

```js

app.get('/', function (req, res, next) {

    ...

})

```

- 여기서 콜백함수에 해당하는 부분을 middleware라고 하고, express는 미들웨어의 연속이라고 할 수 있다.

<br/>

### Q. express 콜백함수 질문입니다.

```js

app.get('/', function (req, res, next) {

    ...

})

```

- 이런 코드가 있을 때 function(req, res...) 부분은

- 자바스크립트 event loop에 의해서 우선 다음코드로 넘어가고

- 나중에 task queue에 들어가게 된후 콜스택이 비게되면 실행되는게 맞나요??

### A.

- 그렇죠! 정확해요 :)

- function(req, res, next) 여기에 작성된 함수 코드들은 콜백함수로 우리가 명시한 '/' 경로에 이벤트가 발생하면 (즉, 클라이언트로부터 해당 경로에 request가 발생하면) 우리가 등록한 콜백함수가 노드 런타임 환경에 의해 태스크 큐에 들어 오게 되고, 이벤트 루프가 적절한 때에 우리의 콜스택으로 가지고 오게 되죠.

- 그래서 function(req, res, next) 함수 안에서 동기적으로 무언가 무거운 일들을 하지 않도록 주의하는 것이 좋아요 ❤️

- 포인트를 제대로 잡고 가시네요 👍

### Q.

- function(req, res, next) 함수에서 무거운 처리를 해야하는거 아닌가요?? 이게 비동기로 실행되니까?

- 엘리님 말씀대로면 무거운 처리를 어디서해야하나용?

### A.

- 우선 무거운 일들이 무엇인지 정의해 보면:

  - 무거운 일 === 블러킹이 발생하는 일들

- 파일을 읽거나 쓰는, 데이터 베이스를 읽거나 쓰는, 네트워크 통신을 하는 이런 일들을 말하겠죠?

- 이렇게 무거운 일들은 비동기적으로 하고 (노드에서 제공하는 API를 사용하거나 또는 데이터베이스를 읽는 함수들을 asnc/promise로 만들어요) 콜백함수에서는 처리된 그 결과값을 가지고 무언가를 업데이트 하는 등의 일들을 할 수 있어요

### Q.

- function(req, res, next)함수가 task queue에서 콜스택으로 넘어와서 실행될때 무거운 일을 하게 되면

- task queue에 있는 다른 함수들이 계속 기다려야 하니까

- function(req, res, next)안에서 다시한번 노드js가 제공하는 비동기함수를 써야한다

- 이렇게 이해하면 맞을까요?

### A.

- 그렇죠 🙌

---

## 11.3 서버 만들기

- https://expressjs.com/en/4x/api.html

---

## 11.6 미들웨어의 중요한 특징

- 콜백함수에서 send를 아래처럼 보낼 수 없기 때문에 꼭 return을 붙여주어야 한다

```js
app.get(
  "/",
  (req, res, next) => {
    console.log("first");

    if (true) {
      // res.send("Hello");, return 없이 한 콜백 함수에서 두개의 res.send 있으면 에러 발생
      return res.send("Hello");
    }
    res.send("Hello2");
  },
  (req, res, next) => {
    console.log("Hello3");
  }
);
```

- all을 사용하면 /blue/color 이런식으로 요청을 하면 처리가 되지 않고 딱 경로가 맞아야지 수행이 된다

```js
app.all("/blue", (req, res, next) => {
  // app.all('/blue/*') 이런식으로 ㄹ하면 blue가 포함된 모든 경로에 대해서 수행이 된다 
  console.log("blue");
  next();
});
```

- use를 사용하면 /red 뿐 아니라 /red/color와 같은 경로를 사용하더라도 호출이 된다

```js
app.use("/red", (req, res, next) => {
  console.log("red");
  next();
});
```

---

## 11.8 에러 처리의 모든것 (동기, 비동기)

### Q. 프로미스 에러 처리 맞게 이해한걸까요?

1. 프로미스는 비동기적인 방식으로 작동한다.

2. 최하단 에러처리는 동기적으로 작동한다.

- 따라서 최하단 에러처리와 프로미스 작동 시점이 맞지 않으므로 프로미스는 자체적으로 에러처리를 해줘야한다. => 5버전부터 한번에 가능하도록 바뀔 예정

### A.

- 넵 맞아요 👍

- 하단 에러처리는 비동기적으로 작동하므로, 그냥 라우터에서 Promise 비동기를 사용하게 되면 에러가 발생 했는지 안했는지 동기적으로 알 수 없으므로 일반적인 에러 처리 함수는 사용할 수 없어요

<br/>

### Q.

- 비동기적이여서 에러를 받지 못하는 이유가 맨 마지막 에러 미들웨어보다 콜백스택 비는게 나중일 수도 있기 때문인가요?

### A.

- 비동기적으로 처리 되고 있는 동안, 연결된 모든 미들웨어 (마지막 에러 미들웨어까지 포함)가 다 완료 되버리기 때문이죠.

- 모든 미들웨어 연결이 끝난다음 (콜스택이 다 비어 지고 나서) 비동기적으로 에러가 발생하면, 그걸 처리 할 수 있는 미들웨어가 없어요 😊

<br/>

### Q.

- 잘 달려오다가 에러 처리에서 promise와 async가 나와서 정신 없이 유튭 복습을 해가며 듣고 있습니다 ㅎㅎㅎㅎ

- 강의 중 promise 의 에러처리중 catch 안에서 next로 에러를 에러처리 미들웨어로 던져주는 부분이 이해되지 않습니다..

- 비동기의 경우 콜스택이 비워진 후 에러가 발생하여 이를 내부적으로 처리해주어야하는 것 아닌가요?

- catch로 에러를 외부로 던지면 에러를 처리하는 미들웨어가 다시수행되는 것인가요?

- 정확한 이해를 위해 질문을 남깁니다.!

### A.

- next() 는 일반 함수와 같아요. catch안에서 에러를 처리 하는 그 어떤 함수를 호출할 수 있는 것처럼 next()를 호출할 수 있어요 🤓

- 클라이언트의 요청에 대해 send나 error로 응답해 주지 않으면 그 요청에 대해서 익스프레스는 대기상태예요. 비동기 적으로 (promise) 특정한 일을 수행후 .then에서 데이터를 클라이언트에게 send 보내 주거나, 또는 .catch에서 에러를 next 보내줄 수 있어요.

### A.

- 미들웨어는 Chain of responsibility 라는 패턴을 구현합니다. 파이프라인에 있는 모든 미들웨어를 돌면서 요청된 상황을 처리할 수 있는, 즉 책임있는 미들웨어가 나타나기를 기다립니다.

- 이때, 미들웨어를 등록한 순서가 중요한데 specific 한 내용을 전반부에 두고 general 한 내용을 뒤로 둡니다. 그리고, 어떤 상황이든 대응할 수 있는 미들웨어를 마지막에 두어서 어떤 식으로든 파이프라인을 종결하고 결과를 돌려줍니다. 이 강의에서는 500 에러 처리가 그 역할을 합니다.

- 어떻게 미들웨어간을 이동할 수 있을까요? 모든 미들웨어에게는 next () 함수가 주어지는데 바로 다음 미들웨어에 대한 함수 포인터라고 볼 수 있습니다. next() 함수를 호출한다는 것은 자신이 책임지고 처리할 수 없다는 의미입니다. next(error) 할때, 바로 다음 미들웨어가 에러 핸들러가 아니라 하더라고 같은 방식으로 next(error) 가 반복 호출되면서 결국 마지막 에러 핸들러까지 타고 가게 됩니다.

- 미들웨어는 자신이 할 수 있는 일을 하고 응답을 돌려 주거나 그렇지 않으면 next()를 호출하는 거죠.

- 헷갈리는 건 app.get() 내부에서 명시적으로 next()를 호출하지 않는 다는 것인데 암묵적으로 express에서 실행해 줄 것이라고 생각됩니다.

### A.

- 다 정확하고, 각각의 미들웨어에서 특정 부분에서 (미들웨어 코드 시작 지점, 중간 지점과 같은) next()를 호출해서 바로 다음 미들웨어로 건너뛰게 만들 수 있고,

- 또는 next()를 별도로 호출하지 않는다면 미들웨어 코드가 다 수행한 뒤에, Express가 자동으로 (암묵적으로) 등록된 다음 미들웨어를 실행해 준답니다.

---

## 11.12 CORS란? 개념과 처리 방법

### CORS (Cross-origin resource sharing)

- 클라이언트와 서버가 동일한 IP에서 주소에서 동작하고 있지만 리소스를 별다른 제약 없이 주고 받을 수 있지만

- 다른 IP를 가진 다면 원칙적으로 그 어떤 데이터를 주고 받을 수 없 다

- 그래서 서버에서 Access-Control-Allow-Origin라는 것을 헤더에 추가해주어야지 브라우저에서 데이터를 가져와서 클라이언트에서 볼 수 있다

<br/>

### Q.

- cors option에 대한 구체적인 설명이 궁금해서 찾아본 내용들을 공유합니다. 해석이 정확하지 않을 수도 있습니다.

- credentials : Access-Control-Allow-Credentials CORS 헤더를 제어합니다. true로 설정될 경우 쿠키, authorization 헤더, TLS 클라이언트 인증서와 같은 자격증명들이 클라이언트에게 노출 된다고 합니다. 이 때, origin은 \*가 아닌 정확한 도메인으로 명시되어야합니다.

- maxAge: Access-Control-Max-Age CORS 헤더를 제어합니다. integer(초 단위)를 value로 받으면, 해당 시간만큼 preflight request를 보내지 않고 이전 preflight request에 대한 응답을 캐시하는 시간을 지정해줍니다.

- optionsSuccessStatus: OPTIONS 요청이 성공 했을 때, IE11이나 다양한 스마트 티비 같은 레거시 브라우저에서 204를 제공해주는데, 204 대신 다른 status 코드를 지정해줄 수 있습니다.

### A.

- 정리하신 내용 공유해 주셔서 감사합니다 👍

- 더 깊이 있게 알아 보고 싶으시면 여기도 확인해 보세요: https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS

<br/>

### Q.

- 실습중에 이해하기 힘든 부분이 있어서 질문드립니다.

```js
app.use(
  cors({
    origin: ["http://127.0.0.1:5500"], //live-server

    methods: ["PUT"],
  })
);
```

- 설정을 해놓았는데요.

- live-server 에서 fetchAPI 를 통해 get 방식으로 통신이 잘 되서요. insomnia(like postman) 에서 method를 OPTOINS 요청하면 Access-Control-Allow-Methods = 'PUT' 로 응답은 잘 받거든요..

- 제가 강의를 들으면서 이해한바로는 등록된 methods 에 대해서만 cors-error 를 발생시키지 않고 정상응답을 하는걸로 이해했거든요.

- 요약하여 질문 요청 사항은

  - cors options 으로 methods 'put' 만 설정하였는데 OPTIONS, GET 방식의 요청에 대해서 응답을 제대로 하는 이유입니다.

### A.

- CORS는 브라우저에서만 해당하는 보안정책으로 Postman이나 다른 서버에서 API 사용하는데는 CORS 관련 헤더 없어도 잘 동작해요 :)

- 브라우저에서 하시면 PUT만 허용되는걸 확인해 볼 수 있을거예요 🙌

### Q.

- 브라우저에서 확인해본결과 ['PUT', 'DELETE'] 는 cors 허용을 안해주면, 원하는대로 cors 에러가 발생되더라고요!

- 그런데.. cors 를 'DELETE' 만 허용해주고 브라우저에서 요청하는 fetchAPI 의 method 를 'GET', 'POST' 도 정상응답이 되었고, 'PUT' 으로 요청했을 때, preflight 요청 'OPTIONS' 도 정상응답이 되었습니다.

- 'GET', 'POST', 'OPTIONS' 를 cors 허용하지 않으려면, 어떻게 해야 될까요?

### A.

- 아하! CORS 오리진이 허용되었다면,

- Get, Head, Post 메소드들은 안전한걸로 간주 되기 때문에, Access-Control-Allow-Methods에 없어도 서버에서 데이터를 받아올 수 있어요 :)

  - (Get, Head, Post 이 친구들을 'simple' 간단한 메소드들이라고 불러요)

- https://developer.mozilla.org/ko/docs/Web/HTTP/CORS

- 이 페이지에서 프리플라이트 요청 부분 보시면 이해에 도움이 될 것 같아요

---

## 11.13 유용한 외부 미들웨어들

- 1분 10초경 브라우저에서 테스트했을때 터미널에 토큰이 출력되는것은

- 강의를 위해서 제가 미리 localhost에 쿠키를 설정해 두어서 보여지는거고,

- 수강생분들 PC에서는 안보여 지는게 맞아요! :)

- 하지만! 바로 이어지는 Postman으로 쿠키를 설정해서 테스트 해보시면 터미널에 나와야 해요.

- 코드를 보시고 싶으시면: 11.14 실습노트에 있는 10-useful-external 폴더를 참고해 주세요 :)
