## 11.2 Express의 큰그림, 중요 포인트!

```js

app.get('/', function (req, res, next) {

    ...

})

```

- 여기서 콜백함수에 해당하는 부분을 middleware라고 하고, express는 미들웨어의 연속이라고 할 수 있다.

<br/>

### Q. express 콜백함수 질문입니다.

```js

app.get('/', function (req, res, next) {

    ...

})

```

- 이런 코드가 있을 때 function(req, res...) 부분은

- 자바스크립트 event loop에 의해서 우선 다음코드로 넘어가고

- 나중에 task queue에 들어가게 된후 콜스택이 비게되면 실행되는게 맞나요??

### A.

- 그렇죠! 정확해요 :)

- function(req, res, next) 여기에 작성된 함수 코드들은 콜백함수로 우리가 명시한 '/' 경로에 이벤트가 발생하면 (즉, 클라이언트로부터 해당 경로에 request가 발생하면) 우리가 등록한 콜백함수가 노드 런타임 환경에 의해 태스크 큐에 들어 오게 되고, 이벤트 루프가 적절한 때에 우리의 콜스택으로 가지고 오게 되죠.

- 그래서 function(req, res, next) 함수 안에서 동기적으로 무언가 무거운 일들을 하지 않도록 주의하는 것이 좋아요 ❤️

- 포인트를 제대로 잡고 가시네요 👍

### Q.

- function(req, res, next) 함수에서 무거운 처리를 해야하는거 아닌가요?? 이게 비동기로 실행되니까?

- 엘리님 말씀대로면 무거운 처리를 어디서해야하나용?

### A.

- 우선 무거운 일들이 무엇인지 정의해 보면:

  - 무거운 일 === 블러킹이 발생하는 일들

- 파일을 읽거나 쓰는, 데이터 베이스를 읽거나 쓰는, 네트워크 통신을 하는 이런 일들을 말하겠죠?

- 이렇게 무거운 일들은 비동기적으로 하고 (노드에서 제공하는 API를 사용하거나 또는 데이터베이스를 읽는 함수들을 asnc/promise로 만들어요) 콜백함수에서는 처리된 그 결과값을 가지고 무언가를 업데이트 하는 등의 일들을 할 수 있어요

### Q.

- function(req, res, next)함수가 task queue에서 콜스택으로 넘어와서 실행될때 무거운 일을 하게 되면

- task queue에 있는 다른 함수들이 계속 기다려야 하니까

- function(req, res, next)안에서 다시한번 노드js가 제공하는 비동기함수를 써야한다

- 이렇게 이해하면 맞을까요?

### A.

- 그렇죠 🙌

---

## 11.3 서버 만들기

- https://expressjs.com/en/4x/api.html

---

## 11.6 미들웨어의 중요한 특징

- 콜백함수에서 send를 아래처럼 보낼 수 없기 때문에 꼭 return을 붙여주어야 한다

```js
app.get(
  "/",
  (req, res, next) => {
    console.log("first");

    if (true) {
      // res.send("Hello");, return 없으면 에러 발생
      return res.send("Hello");
    }
    res.send("Hello2");
  },
  (req, res, next) => {
    console.log("Hello3");
  }
);
```

- all을 사용하면 /blue/color 이런식으로 요청을 하면 처리가 되지 않고 딱 경로가 맞아야지 수행이 된다

```js
app.all("/blue", (req, res, next) => {
  console.log("blue");
  next();
});
```

- use를 사용하면 /red 뿐 아니라 /red/color와 같은 경로를 사용하더라도 호출이 된다

```js
app.use("/red", (req, res, next) => {
  console.log("red");
  next();
});
```

---

## 11.8 에러 처리의 모든것 (동기, 비동기)

### Q. 프로미스 에러 처리 맞게 이해한걸까요?

1. 프로미스는 비동기적인 방식으로 작동한다.

2. 최하단 에러처리는 동기적으로 작동한다.

- 따라서 최하단 에러처리와 프로미스 작동 시점이 맞지 않으므로 프로미스는 자체적으로 에러처리를 해줘야한다. => 5버전부터 한번에 가능하도록 바뀔 예정

### A.

- 넵 맞아요 👍

- 하단 에러처리는 비동기적으로 작동하므로, 그냥 라우터에서 Promise 비동기를 사용하게 되면 에러가 발생 했는지 안했는지 동기적으로 알 수 없으므로 일반적인 에러 처리 함수는 사용할 수 없어요

<br/>

### Q.

- 비동기적이여서 에러를 받지 못하는 이유가 맨 마지막 에러 미들웨어보다 콜백스택 비는게 나중일 수도 있기 때문인가요?

### A.

- 비동기적으로 처리 되고 있는 동안, 연결된 모든 미들웨어 (마지막 에러 미들웨어까지 포함)가 다 완료 되버리기 때문이죠.

- 모든 미들웨어 연결이 끝난다음 (콜스택이 다 비어 지고 나서) 비동기적으로 에러가 발생하면, 그걸 처리 할 수 있는 미들웨어가 없어요 😊

<br/>

### Q.

- 잘 달려오다가 에러 처리에서 promise와 async가 나와서 정신 없이 유튭 복습을 해가며 듣고 있습니다 ㅎㅎㅎㅎ

- 강의 중 promise 의 에러처리중 catch 안에서 next로 에러를 에러처리 미들웨어로 던져주는 부분이 이해되지 않습니다..

- 비동기의 경우 콜스택이 비워진 후 에러가 발생하여 이를 내부적으로 처리해주어야하는 것 아닌가요?

- catch로 에러를 외부로 던지면 에러를 처리하는 미들웨어가 다시수행되는 것인가요?

- 정확한 이해를 위해 질문을 남깁니다.!

### A.

- next() 는 일반 함수와 같아요. catch안에서 에러를 처리 하는 그 어떤 함수를 호출할 수 있는 것처럼 next()를 호출할 수 있어요 🤓

- 클라이언트의 요청에 대해 send나 error로 응답해 주지 않으면 그 요청에 대해서 익스프레스는 대기상태예요. 비동기 적으로 (promise) 특정한 일을 수행후 .then에서 데이터를 클라이언트에게 send 보내 주거나, 또는 .catch에서 에러를 next 보내줄 수 있어요.

### A.

- 미들웨어는 Chain of responsibility 라는 패턴을 구현합니다. 파이프라인에 있는 모든 미들웨어를 돌면서 요청된 상황을 처리할 수 있는, 즉 책임있는 미들웨어가 나타나기를 기다립니다.

- 이때, 미들웨어를 등록한 순서가 중요한데 specific 한 내용을 전반부에 두고 general 한 내용을 뒤로 둡니다. 그리고, 어떤 상황이든 대응할 수 있는 미들웨어를 마지막에 두어서 어떤 식으로든 파이프라인을 종결하고 결과를 돌려줍니다. 이 강의에서는 500 에러 처리가 그 역할을 합니다.

- 어떻게 미들웨어간을 이동할 수 있을까요? 모든 미들웨어에게는 next () 함수가 주어지는데 바로 다음 미들웨어에 대한 함수 포인터라고 볼 수 있습니다. next() 함수를 호출한다는 것은 자신이 책임지고 처리할 수 없다는 의미입니다. next(error) 할때, 바로 다음 미들웨어가 에러 핸들러가 아니라 하더라고 같은 방식으로 next(error) 가 반복 호출되면서 결국 마지막 에러 핸들러까지 타고 가게 됩니다.

- 미들웨어는 자신이 할 수 있는 일을 하고 응답을 돌려 주거나 그렇지 않으면 next()를 호출하는 거죠.

- 헷갈리는 건 app.get() 내부에서 명시적으로 next()를 호출하지 않는 다는 것인데 암묵적으로 express에서 실행해 줄 것이라고 생각됩니다.

### A.

- 다 정확하고, 각각의 미들웨어에서 특정 부분에서 (미들웨어 코드 시작 지점, 중간 지점과 같은) next()를 호출해서 바로 다음 미들웨어로 건너뛰게 만들 수 있고,

- 또는 next()를 별도로 호출하지 않는다면 미들웨어 코드가 다 수행한 뒤에, Express가 자동으로 (암묵적으로) 등록된 다음 미들웨어를 실행해 준답니다.
